# 🧠 LeetCode Daily Interview Prep (Python)

This repo contains my daily interview problem solving progress in preparation for tech interviews.

## ✅ Progress

| Day   | Problems                                                                                                                                                                                                                                                                         | Notes                                                                                                                                                                                                                                                                                                                                                                     |
| ----- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Day 1 | [Two Sum](./day1/001-two-sum.py), [Contains Duplicate](./day1/217-contains-duplicate.py), [Best Time to Buy and Sell Stock](./day1/121-best-time-to-buy-and-sell-stock.py)                                                                                                       | Basic syntax like for-loop, enumerate, and `if in` felt unfamiliar. Took time to adjust to Python's way of writing logic. I felt very hopeless but I will improve                                                                                                                                                                                                         |
| Day 2 | [Longest Substring...](./day2/003-longest-substring-without-repeating-characters.py), [Valid Anagram](./day2/242-valid-anagram.py), [Ransom Note](./day2/383-ransom-note.py)                                                                                                     | 1번: Sliding window + dict 패턴 구현에 50분 걸림. 처음이라 디버깅 많았음. 2번: 문자 개수 세는 패턴 익힘. Counter 없이 dict로 구현해봄. 3번: Counter 써보면서 dict보다 깔끔한 방식 이해함. 전체적으로 문자열 문제에 감 잡힘.                                                                                                                                               |
| Day 3 | [Valid Parentheses](./day3/020-valid-parentheses.py), [Running Sum of 1D Array](./day3/1480-running-sum-of-1d-array.py), [Maximum Subarray](./day3/053-maximum-subarray.py)                                                                                                      | - Python에서 stack은 list의 `append()`/`pop()`으로 구현 가능함<br>- `Kadane’s Algorithm`을 적용해 최대 부분합 문제 해결<br>- running sum은 prefix sum 기초로 매우 직관적이었음<br>- 처음 pointer로 접근했다가 꼬인 경험이 유익했음                                                                                                                                        |
| Day 4 | [Intersection of Two Arrays II](./day4/350-intersection-of-two-arrays-ii.py), [Binary Search](./day4/704-binary-search.py), [First Bad Version](./day4/278-first-bad-version.py)                                                                                                 | - `Counter`와 `dict` 두 방식 모두로 풀이하며 차이점 학습함<br>- Binary Search 재귀 방식으로 구현 후 iterative 방식과 비교함<br>- 조건을 만족하는 첫 인덱스를 찾는 "Binary Search on Answer" 패턴 이해함                                                                                                                                                                   |
| Day 5 | [Merge Sorted Array](./day5/088-merge-sorted-array.py), [Move Zeroes](./day5/283-move-zeroes.py), [Valid Palindrome](./day5/125-valid-palindrome.py), [Group Anagrams](./day5/049-group-anagrams.py)                                                                             | - 뒤에서부터 채워넣는 in-place merge 패턴 학습<br>- 투 포인터로 배열 재배치(0 이동) 훈련<br>- `isalnum` 활용한 문자열 전처리 익힘<br>- `defaultdict`와 `sorted`/카운트 튜플 방식을 통한 그룹핑 전략 이해                                                                                                                                                                  |
| Day 6 | [Reverse Linked List](./day6/206-reverse-linked-list.py), [Linked List Cycle](./day6/141-linked-list-cycle.py), [Min Stack](./day6/155-min-stack.py)                                                                                                                             | - Linked List는 값이 아니라 **노드 객체 참조**로 연결됨을 이해<br>- Reverse Linked List는 포인터(prev, curr, next) 패턴으로 O(n) 시간에 해결<br>- Linked List Cycle은 set 방문 기록(O(n) 공간)과 Floyd 알고리즘(O(1) 공간) 두 가지 접근법 학습<br>- Min Stack은 보조 스택을 유지하여 getMin을 O(1)로 구현                                                                 |
| Day 7 | [Maximum Depth of Binary Tree](./day7/104-maximum-depth-of-binary-tree.py), [Binary Tree Level Order Traversal](./day7/102-binary-tree-level-order-traversal.py), [Validate Binary Search Tree](./day7/098-validate-binary-search-tree.py)                                       | - 트리 기본 패턴 학습<br>- DFS 재귀로 최대 깊이 구하기, BFS(큐+level_size)로 레벨 탐색 구현<br>- Validate BST는 단순 부모 비교로는 부족하고 (low, high) 범위 전달 필요<br>- 빈 트리/단일 노드/Skewed 트리 같은 edge case도 BST로 간주됨                                                                                                                                   |
| Day 8 | [Invert Binary Tree](./day8/226-invert-binary-tree.py), [Lowest Common Ancestor of BST](./day8/235-lowest-common-ancestor-of-a-bst.py), [Kth Smallest Element in a BST](./day8/230-kth-smallest-element-in-a-bst.py), [Balanced Binary Tree](./day8/110-balanced-binary-tree.py) | - `Invert`는 DFS 재귀가 가장 직관적, BFS로도 구현 가능<br>- `LCA in BST`는 경로저장 DFS 대신 BST 성질(왼<root<오른)로 해결해야 함<br>- `Kth Smallest`는 BST의 inorder traversal이 정렬이라는 성질을 활용, k번째 방문 노드가 정답<br>- `Balanced Tree`는 전역 min/max depth 비교가 아니라 **각 노드 단위 post-order DFS**로 높이 차이를 검사해야 함                        |
| Day 9 | [Number of Islands](./day9/200-number-of-islands.py), [Flood Fill](./day9/733-flood-fill.py), [Max Area of Island](./day9/695-max-area-of-island.py), [Clone Graph](./day9/133-clone-graph.py)                                                                                   | - `Number of Islands`: DFS/BFS로 연결 요소 탐색, grid 수정 vs visited set 두 방법 비교<br>- `Flood Fill`: 색이 같은 영역을 DFS로 퍼뜨리며 무한재귀 방지 조건(start==color) 추가 학습<br>- `Max Area of Island`: DFS 재귀로 크기 누적, BFS 변환도 연습<br>- `Clone Graph`: Medium 난이도, dict 매핑(old→new)으로 사이클 방지 & 복사 구현. BFS/DFS 둘 다 가능하다는 점 학습 |
