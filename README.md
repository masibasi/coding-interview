# 🧠 LeetCode Daily Interview Prep (Python)

This repo contains my daily interview problem solving progress in preparation for tech interviews.

## ✅ Progress

| Day    | Problems                                                                                                                                                                                                                                                                         | Notes                                                                                                                                                                                                                                                                                                                                                                     |
| ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Day 1  | [Two Sum](./day1/001-two-sum.py), [Contains Duplicate](./day1/217-contains-duplicate.py), [Best Time to Buy and Sell Stock](./day1/121-best-time-to-buy-and-sell-stock.py)                                                                                                       | Basic syntax like for-loop, enumerate, and `if in` felt unfamiliar. Took time to adjust to Python's way of writing logic. I felt very hopeless but I will improve                                                                                                                                                                                                         |
| Day 2  | [Longest Substring...](./day2/003-longest-substring-without-repeating-characters.py), [Valid Anagram](./day2/242-valid-anagram.py), [Ransom Note](./day2/383-ransom-note.py)                                                                                                     | 1번: Sliding window + dict 패턴 구현에 50분 걸림. 처음이라 디버깅 많았음. 2번: 문자 개수 세는 패턴 익힘. Counter 없이 dict로 구현해봄. 3번: Counter 써보면서 dict보다 깔끔한 방식 이해함. 전체적으로 문자열 문제에 감 잡힘.                                                                                                                                               |
| Day 3  | [Valid Parentheses](./day3/020-valid-parentheses.py), [Running Sum of 1D Array](./day3/1480-running-sum-of-1d-array.py), [Maximum Subarray](./day3/053-maximum-subarray.py)                                                                                                      | - Python에서 stack은 list의 `append()`/`pop()`으로 구현 가능함<br>- `Kadane’s Algorithm`을 적용해 최대 부분합 문제 해결<br>- running sum은 prefix sum 기초로 매우 직관적이었음<br>- 처음 pointer로 접근했다가 꼬인 경험이 유익했음                                                                                                                                        |
| Day 4  | [Intersection of Two Arrays II](./day4/350-intersection-of-two-arrays-ii.py), [Binary Search](./day4/704-binary-search.py), [First Bad Version](./day4/278-first-bad-version.py)                                                                                                 | - `Counter`와 `dict` 두 방식 모두로 풀이하며 차이점 학습함<br>- Binary Search 재귀 방식으로 구현 후 iterative 방식과 비교함<br>- 조건을 만족하는 첫 인덱스를 찾는 "Binary Search on Answer" 패턴 이해함                                                                                                                                                                   |
| Day 5  | [Merge Sorted Array](./day5/088-merge-sorted-array.py), [Move Zeroes](./day5/283-move-zeroes.py), [Valid Palindrome](./day5/125-valid-palindrome.py), [Group Anagrams](./day5/049-group-anagrams.py)                                                                             | - 뒤에서부터 채워넣는 in-place merge 패턴 학습<br>- 투 포인터로 배열 재배치(0 이동) 훈련<br>- `isalnum` 활용한 문자열 전처리 익힘<br>- `defaultdict`와 `sorted`/카운트 튜플 방식을 통한 그룹핑 전략 이해                                                                                                                                                                  |
| Day 6  | [Reverse Linked List](./day6/206-reverse-linked-list.py), [Linked List Cycle](./day6/141-linked-list-cycle.py), [Min Stack](./day6/155-min-stack.py)                                                                                                                             | - Linked List는 값이 아니라 **노드 객체 참조**로 연결됨을 이해<br>- Reverse Linked List는 포인터(prev, curr, next) 패턴으로 O(n) 시간에 해결<br>- Linked List Cycle은 set 방문 기록(O(n) 공간)과 Floyd 알고리즘(O(1) 공간) 두 가지 접근법 학습<br>- Min Stack은 보조 스택을 유지하여 getMin을 O(1)로 구현                                                                 |
| Day 7  | [Maximum Depth of Binary Tree](./day7/104-maximum-depth-of-binary-tree.py), [Binary Tree Level Order Traversal](./day7/102-binary-tree-level-order-traversal.py), [Validate Binary Search Tree](./day7/098-validate-binary-search-tree.py)                                       | - 트리 기본 패턴 학습<br>- DFS 재귀로 최대 깊이 구하기, BFS(큐+level_size)로 레벨 탐색 구현<br>- Validate BST는 단순 부모 비교로는 부족하고 (low, high) 범위 전달 필요<br>- 빈 트리/단일 노드/Skewed 트리 같은 edge case도 BST로 간주됨                                                                                                                                   |
| Day 8  | [Invert Binary Tree](./day8/226-invert-binary-tree.py), [Lowest Common Ancestor of BST](./day8/235-lowest-common-ancestor-of-a-bst.py), [Kth Smallest Element in a BST](./day8/230-kth-smallest-element-in-a-bst.py), [Balanced Binary Tree](./day8/110-balanced-binary-tree.py) | - `Invert`는 DFS 재귀가 가장 직관적, BFS로도 구현 가능<br>- `LCA in BST`는 경로저장 DFS 대신 BST 성질(왼<root<오른)로 해결해야 함<br>- `Kth Smallest`는 BST의 inorder traversal이 정렬이라는 성질을 활용, k번째 방문 노드가 정답<br>- `Balanced Tree`는 전역 min/max depth 비교가 아니라 **각 노드 단위 post-order DFS**로 높이 차이를 검사해야 함                        |
| Day 9  | [Number of Islands](./day9/200-number-of-islands.py), [Flood Fill](./day9/733-flood-fill.py), [Max Area of Island](./day9/695-max-area-of-island.py), [Clone Graph](./day9/133-clone-graph.py)                                                                                   | - `Number of Islands`: DFS/BFS로 연결 요소 탐색, grid 수정 vs visited set 두 방법 비교<br>- `Flood Fill`: 색이 같은 영역을 DFS로 퍼뜨리며 무한재귀 방지 조건(start==color) 추가 학습<br>- `Max Area of Island`: DFS 재귀로 크기 누적, BFS 변환도 연습<br>- `Clone Graph`: Medium 난이도, dict 매핑(old→new)으로 사이클 방지 & 복사 구현. BFS/DFS 둘 다 가능하다는 점 학습 |
| Day 10 | [Rotting Oranges](./day10/994-rotting-oranges.py), [01 Matrix](./day10/542-01-matrix.py), [Course Schedule](./day10/207-course-schedule.py), [Course Schedule II](./day10/210-course-schedule-ii.py)                                                                             | - BFS에서 동시에 여러 시작점을 큐에 넣는 멀티소스 BFS 패턴을 익힘<br>- DP 2-pass 풀이처럼 다른 접근 방식도 있다는 걸 알게 됨<br>- 코스 스케줄은 DFS(0/1/2 마킹)와 BFS(Kahn’s Algorithm) 두 방식 모두 연습                                                                                                                                                                 |
| Day 11 | [Climbing Stairs](./day11/070-climbing-stairs.py), [House Robber](./day11/198-house-robber.py), [Min Cost Climbing Stairs](./day11/746-min-cost-climbing-stairs.py), [Longest Repeating Character Replacement](./day11/424-longest-repeating-character-replacement.py)           | - 점화식 세우는 기본 패턴 습득: `dp[i] = dp[i-1] + dp[i-2]` 계열<br>- House Robber에서 `max(dp[i-1], dp[i-2]+nums[i])` 구조 익힘<br>- 공간 최적화(O(1))로 `prev1, prev2`만 쓰는 패턴 연습<br>- 슬라이딩 윈도우 문제(424): `윈도우 길이 - 최빈도 <= k`라는 조건을 유지하는 방식 학습                                                                                       |

---

## 🎯 TikTok OA Prep Progress

| Day   | Problems                                                                                                                                                                                                                                                                       | Notes                                                                                                                                                                                                              |
| ----- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Day 1 | [Two Sum](./tiktok/day1/001-two-sum.py), [Valid Anagram](./tiktok/day1/242-valid-anagram.py), [Valid Palindrome](./tiktok/day1/125-valid-palindrome.py), [Longest Substring Without Repeating Characters](./tiktok/day1/003-longest-substring-without-repeating-characters.py) | - Hash map으로 complement 찾기(O(1) lookup) 패턴 복습<br>- 문자열 전처리: `isalnum`, `lower`, `Counter` 활용<br>- Sliding Window(set vs dict) 두 버전 모두 학습                                                    |
| Day 2 | [Best Time to Buy and Sell Stock](../tiktok/day2/121-best-time-to-buy-and-sell-stock.py), [Contains Duplicate](../tiktok/day2/217-contains-duplicate.py), [Valid Parentheses](../tiktok/day2/020-valid-parentheses.py), [Binary Search](../tiktok/day2/704-binary-search.py)   | - 최소값 추적 + 차이 계산으로 최댓값 갱신 패턴 익힘<br>- Set을 활용한 중복 탐지 O(n)<br>- Stack으로 괄호 짝짓기 검증<br>- Binary Search는 `//2`로 mid 구하고 left/right 갱신하는 iterative 패턴 정리               |
| Day 3 | [Climbing Stairs](../tiktok/day3/070-climbing-stairs.py), [Move Zeroes](../tiktok/day3/283-move-zeroes.py), [Invert Binary Tree](../tiktok/day3/226-invert-binary-tree.py), [Flood Fill](../tiktok/day3/733-flood-fill.py)                                                     | - DP 점화식(`dp[i] = dp[i-1] + dp[i-2]`)으로 계단 문제 해결<br>- Two Pointers로 in-place 배열 조작 패턴 연습<br>- 트리 문제는 DFS로 간단히 풀 수 있음<br>- Grid DFS/BFS에서 경계 조건·방문 체크 타이밍 중요성 체감 |
